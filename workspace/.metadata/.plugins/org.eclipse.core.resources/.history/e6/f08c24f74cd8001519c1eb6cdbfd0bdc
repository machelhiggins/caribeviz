package com.uwiseismic.ergo.buildingclassifier;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;

import org.geotools.feature.IllegalAttributeException;
import org.opengis.feature.simple.SimpleFeature;

import com.uwiseismic.ergo.buildingclassifier.logistic.LogisticFunction;
import com.uwiseismic.util.geohash.GeoHash;
import com.uwiseismic.util.geohash.GeoHashable;
import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.GeometryFactory;
import com.vividsolutions.jts.geom.LinearRing;
import com.vividsolutions.jts.geom.Point;
import com.vividsolutions.jts.geom.Polygon;

public class BuildingClassification implements GeoHashable{

	private String bldgID;
	private SimpleFeature feature;
	private GeoHash allBuildings;
	
	/*
	 *  Probabilities, metrics and required statistics for prob functions
	 */
	private int noOfVertices = 0;
	//** circle that encompassses this structure's neighbors
	private Geometry circle; 
	//** this structure's neighbours
	private Collection neighbors;
	//** Isoperimetric Quotient 
	private double isoperimetricQ = 0;
	private double isoperimetricQOrig = 0;
	private ArrayList<String> isoperimetricQStatsNeeded;//** required statistics for isoperimetric value
	private HashMap <String, Double>isoperimetricQVarsValues = new HashMap <String, Double>(); //** variables and their values the probability function MAY require
	
	//** Isoperimetric Quotient similarity to neighbours
	private double isoperimetricQNeighborhood = 0;
	private ArrayList<String> isoPQNStatsNeeded;//** required statistics for isoperimetricQ of neighbors
	private HashMap <String, Double>isoPQNVarsValues = new HashMap <String, Double>(); //** variables and their values the probability function MAY require	
	
	//** major road proxmity metric
	private double majorRoadIndex = 0;
	private double majorRoadIndexOrig = 0;
	private ArrayList<String> mriStatsNeeded;//** required statistics for major road proximity index
	private HashMap <String, Double>mriVarsValues = new HashMap <String, Double>(); //** variables and their values the probability function MAY require	
	
	//** building ground floor area	
	private double gsqm = 0;
	private double gsqmOrig = 0;
	private ArrayList<String> gsqmStatsNeeded = new ArrayList<String>();//** required statistics for gsqm
	private HashMap <String, Double>gsqmVarsValues = new HashMap <String, Double>(); //** variables and their values the probability function MAY require

	//** building ground floor area similarirty to neighbors
	private double gsqmNeighborhood = 0;
	private ArrayList<String> gsqmNStatsNeeded;//** required statistics for gsqm  of neighbors
	private HashMap <String, Double>gsqmNeighVarsValues = new HashMap <String, Double>(); //** variables and their values the probability function MAY require	

	//** Income zone of the ED we're in 
	private double meanUnImpLandValue = 0;
	private ArrayList<String> inzStatsNeeded;//** required statistics for income zone (NONE!)
	private HashMap <String, Double>inzVarsValues = new HashMap <String, Double>(); //** variables and their values the probability function MAY require	
	
	//** Ratio of structure types for surrounding structures
	private double neighborStructs[] = new double[ProbConstants.STRUCT_TYPES.length];
	private StructureProbabilities neighborStructProb =  new StructureProbabilities(); //** not so much of a probability but a weight	
	
	//** ED Structure Ranking function
	private EDStructTypeRankingFunction ed;
	//** Probability parameters for each metric
	private BuildingProbParameters probParams;
	
	//** structure type probability
	private String likelyStructureStr;
	private int likelyStructure;
	private double likelyStructureProb = 0;
	private double structProbs[] = new double[ProbConstants.STRUCT_TYPES.length];
	private boolean calculatedStructuresProb = false;
	private boolean userSetStructProb = false;
	//** occupancy type probability	
	private double comProb = 0;
	private double resProb = 0;
	private double indProb = 0; 
	private final double NOT_USER_SET_PROB_THRESHOLD = 0.8; //** arbritrary value to check if user, calculated or default prob
	
	//** for MC simulation
	//private ArrayList <Integer>likelyStructureMemory = new ArrayList<Integer>();
	private int likelyStructureMemory[] = new int[ProbConstants.STRUCT_TYPES.length];
	//private ArrayList <double[]>likelyStructureProbMemory = new ArrayList<double[]>();
	//TODO: for now we're gonna average probabilities. 
	private double[] likelyStructureProbMemory = new double[ProbConstants.STRUCT_TYPES.length];
	
	
	public BuildingClassification(SimpleFeature feature){
		this.feature = feature;
		
		Object id = feature.getAttribute("bldg_id");
		if(id instanceof String)
			bldgID = (String)id;
		else if(id instanceof Integer)
			bldgID = ((Integer)id).toString();
		else if(id instanceof Long)
			bldgID = ((Long)id).toString();
		noOfVertices = ((Integer)feature.getAttribute("n_vertices")).intValue();
		isoperimetricQ = ((Double)feature.getAttribute("isop_q")).doubleValue();
		majorRoadIndex = ((Double)feature.getAttribute("road_index")).doubleValue();		
		gsqm = ((Double)feature.getAttribute("area_sqm")).doubleValue();		
		likelyStructureStr = (String)feature.getAttribute("struct_typ");
		if(likelyStructureStr == null)
			likelyStructureStr = (String)feature.getAttribute("struct_typ");
		likelyStructure = ProbConstants.getStructureType(likelyStructureStr);
		if(feature.getAttribute("str_prob") != null)
			likelyStructureProb = ((Double)feature.getAttribute("str_prob")).doubleValue();
		else
			likelyStructureProb = ((Double)feature.getAttribute("STR_PROB")).doubleValue();
		
			
		if(likelyStructureProb > NOT_USER_SET_PROB_THRESHOLD)
			userSetStructProb = true;
			
		for(int i = 0;  i < likelyStructureProbMemory.length; i++)
			likelyStructureProbMemory[i] = 0;
					
		isoperimetricQOrig = isoperimetricQ;
		majorRoadIndexOrig = majorRoadIndex;
		gsqmOrig = gsqm;	
	}	
	
private void DEBUG(){/******************************************** DELETE ME ************/

	for(int z = 0; z < structProbs.length; z++){/******************************************** DELETE ME ************/
		System.out.print(structProbs[z]+"\t");/******************************************** DELETE ME ************/
	}/******************************************** DELETE ME ************/
	System.out.println();/******************************************** DELETE ME ************/
	for(int i = 0; i < ProbConstants.STRUCT_TYPES.length; i++){//REMOVE ME PLEASE/******************************************** DELETE ME ************/		
		structProbs[i] = 1;		/******************************************** DELETE ME ************/
	}/******************************************** DELETE ME ************/
}
public boolean DEBUG = false;


	public void setProbParams(BuildingProbParameters probParams) {		
		//**TODO: IF WE HAVE TO ALTER INDIVIDUAL BuildingProbParameters during MC, DO deep clone here 			
		this.probParams = probParams;		
		mriStatsNeeded = probParams.getRequiredStatistics(ProbConstants.RP);
		isoperimetricQStatsNeeded = probParams.getRequiredStatistics(ProbConstants.BSR);
		gsqmStatsNeeded = probParams.getRequiredStatistics(ProbConstants.BA);
		gsqmNStatsNeeded = probParams.getRequiredStatistics(ProbConstants.BAN);		
		isoPQNStatsNeeded = probParams.getRequiredStatistics(ProbConstants.BSRN);		
		inzStatsNeeded = probParams.getRequiredStatistics(ProbConstants.INZ);
	}
	
	public void resetIndices(){
		//TODO: Add new indices here
		isoperimetricQ = isoperimetricQOrig;
		majorRoadIndex = majorRoadIndexOrig;
		gsqm = gsqmOrig;	
	}

	public void determineStructure(boolean calculateIndices) throws StructureNotInEdException, NoProbabilityFunctionException{
		
		if(probParams == null)
			throw new NoProbabilityFunctionException("Required object "+BuildingProbParameters.class.getName()+" was not set for this class");
		if(ed == null){
			if(likelyStructureStr == null)
				likelyStructure = ProbConstants.RM2; //** most dominant type in caribbean
			if(!userSetStructProb)
				likelyStructureProb = 0.00001;
			throw new StructureNotInEdException("Required object "+EDStructTypeRankingFunction.class.getName()+" was not set for this class (building id = "+bldgID+")");
		}
		if(circle == null)
			createNeighborhoodCircle();
		if(neighbors == null)
			neighbors = allBuildings.getContaining(circle); 			
	
		// Calculate what has to be calculated
		// TODO :: !!! SHOULD WE DO THIS ONLY ONCE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		if(calculateIndices){
			this.doGsqm();
			this.doGsqmNeighborhood();
			this.doMajorRoadIndex();
			this.doIsoperimetricQ();
			this.doIsoperimetricQNeighborhood();
			this.doIncomeZone();
			this.doNeighbouringStructTypes();
		}
		
		//** reset structure probability
		for(int i = 0; i < ProbConstants.STRUCT_TYPES.length; i++){
			if(userSetStructProb && ProbConstants.STRUCT_TYPES[i].equals(this.getMostLikelyStructureString())){
				structProbs[i] = likelyStructureProb;
			}
			else
				structProbs[i] = 1;		
		}
			
		
		//** Evaluate for each metric			
		//TODO: make sure to make weight variable for MCMC
		if(!userSetStructProb){
					
			//** EDStructRanking
			if(DEBUG){
				System.out.println("RM \t RM1 \t RM2 \t C1 \t C2 \t W1 \t S1 \t PC1 \t URM");//*** DEBUG********
				System.out.println("ED "+ed.getID());
				DEBUG();	
			}
			
			//** Major Road Proxmity Index
			applyStructureProb(probParams.getProbabilitiesFromMetric(ProbConstants.RP, majorRoadIndex, mriVarsValues, false),1, false, 0);
			if(DEBUG){
				System.out.println("RP "+this.majorRoadIndex);
				DEBUG();
			}
			
			//** Building Footprint Area Metric
			applyStructureProb(probParams.getProbabilitiesFromMetric(ProbConstants.BA, gsqm, gsqmVarsValues, false),1, false, 0);
			if(DEBUG){
			System.out.println("BA "+this.gsqm+"\t Neighbor mean = "+gsqmVarsValues.get(ProbConstants.MEAN)+ "\tmean+sigma = "+gsqmVarsValues.get(ProbConstants.MEAN_PLUS_SIGMA));
			DEBUG();
			}
			
			//** Building Footprint Area Similarity to Neighbors Metric
			applyStructureProb(probParams.getProbabilitiesFromMetric(ProbConstants.BAN, gsqmNeighborhood, gsqmNeighVarsValues, false),1, false, 0);
			if(DEBUG){
			System.out.println("BAN "+this.gsqmNeighborhood+"\t Neighbor mode = "+gsqmNeighVarsValues.get(ProbConstants.MODE));
			DEBUG();
			}
			
			//** Building Footprint Shape Regularity Metric
			applyStructureProb(probParams.getProbabilitiesFromMetric(ProbConstants.BSR, isoperimetricQ, isoperimetricQVarsValues, false),1, false, 0);
			if(DEBUG){
			System.out.println("BSR "+this.isoperimetricQ);
			DEBUG();
			}
			//** Building Footprint Shape Regulartiy Similarity to Neighbors Metric
			applyStructureProb(probParams.getProbabilitiesFromMetric(ProbConstants.BSRN, isoperimetricQNeighborhood, isoPQNVarsValues, false),1, false, 0);
			if(DEBUG){
			System.out.println("BSRN "+this.isoperimetricQNeighborhood+"\t Neighbor sigma = "+isoPQNVarsValues.get(ProbConstants.SIGMA));
			DEBUG();
			}
			
			//** Income zone metric
			if(DEBUG)
				//applyStructureProb(probParams.getProbabilitiesFromMetric(ProbConstants.INZ, ed.getMeanUnimpLandVal(), inzVarsValues, false),1, false, 0);
				applyStructureProb(probParams.getProbabilitiesFromMetric(ProbConstants.INZ, meanUnImpLandValue, inzVarsValues, false),1, false, 0);
			else
				applyStructureProb(probParams.getProbabilitiesFromMetric(ProbConstants.INZ, meanUnImpLandValue, inzVarsValues, false),1, false, 0);
			if(DEBUG){
			System.out.println("INZ "+ed.getMeanUnimpLandVal()+"\t 90 percentile = "+inzVarsValues.get(ProbConstants.UPPER_NINETY_PERCENTILE));
			DEBUG();
			}
			
			//** neighbouring structure type WEIGHTING, NOT PROBABILITY
			if(calculatedStructuresProb){
				applyStructureProb(neighborStructProb,1, false, 0);
				if(DEBUG){
					System.out.println("Neighbor Ratios");
					DEBUG();
				}
			}
			structProbs[ProbConstants.URM] = 0.0000000001;//** TODO: DELETE, not estimating for now			
			

			determineWinningStruct();			
		
			feature.setAttribute("struct_typ", likelyStructureStr);
			feature.setAttribute("str_prob", new Double(likelyStructureProb));
		}		
		
		calculatedStructuresProb = true;
	}
	
	/**
	 * 
	 * From structures' probabilities will select the the most likely structure and its probability
	 * @return
	 */
	public int determineWinningStruct(){
		//** whats the winning structure
		int winningStruct = -1;
		double maxProb = -Double.MAX_VALUE;
		for(int i = 0; i < ProbConstants.STRUCT_TYPES.length; i++){
			if(structProbs[i] > maxProb){
				maxProb = structProbs[i];
				winningStruct = i;
			}				
		}
		if(DEBUG){
			System.out.println("Winning structure is : "+winningStruct);
		}
		//TODO: IF MOST LIKELY STRUCTURE IS RM LETS CHOOSE second most likely, RM is for debugging purposes
		// and may be used if RM1 and RM2 cannot be separated
		if(winningStruct == ProbConstants.RM){
			/*System.err.print("Found a RM, probabilities : ");
			for(int i = 0; i < structProbs.length;  i++)
				System.err.print(structProbs[i]+"\t");
			System.err.println();*/
			//** search for next best
			maxProb = -Double.MAX_VALUE;
			for(int i = 0; i < ProbConstants.STRUCT_TYPES.length; i++){
				if(i != winningStruct && structProbs[i] > maxProb){
					maxProb = structProbs[i];
					winningStruct = i;
				}				
			}
			//winningStruct = ProbConstants.RM1;
		}
		this.likelyStructure = winningStruct;
		this.likelyStructureStr = ProbConstants.getStructureType(winningStruct);		
		this.likelyStructureProb = structProbs[winningStruct];
		return winningStruct;
	}
	
	/**
	 * 
     * This method is to facilitate the selection of W1 after outside processes (like the monte carlo simulation)
     *  because the RM2 probability will always be higher than the user specified P(W1).This is simply because 
     *  of the dominating prevalence of RM2. 		
	 * 
	 */
	public void determineIfWinningStructCouldBeW1(){
		int winningStruct;
		/** if this RM2 and more likely a residential structure, must assume that it can also be a W1.
		 */
		if(likelyStructure == ProbConstants.RM2){
			System.err.println("DEBUG: Checking if this RM2 should be W1!");
			//** first structure must be in low income ed's  AND is DEFINITELY less that 215 sqm (the mean according to survey)
			if(ed.getMeanUnimpLandVal() < inzVarsValues.get(ProbConstants.UPPER_NINETY_PERCENTILE)
					&& gsqm < 230){
				//** The WR index uses RatioFunction which will probabilistically determine if it should be W1 
				StructureProbabilities sp;
				try {
					sp = probParams.getProbabilitiesFromMetric(ProbConstants.WR, 0, null, false);									
					if(sp.rm2 < sp.w1){
						structProbs[ProbConstants.W1] = structProbs[ProbConstants.RM2];
						structProbs[ProbConstants.RM2] = structProbs[ProbConstants.RM2]*0.8999;
						System.err.println("DEBUG: Switching from RM2 to W1!");
					}					
					determineWinningStruct();
				} catch (NoProbabilityFunctionException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}									
		}		
	}
	
	/**
	 * Due to error in building footpritns, a higher than normal amount of RM2 are classified as RM1. If this object statisically represents
	 * a RM1 then it will be come an RM2 if P(RM1) < 0.7 and not P(C1 | C2) > 0.25 
	 */
	public void determineIfRM1CouldBeRM2(){
		if(likelyStructure == ProbConstants.RM1){
			System.err.println("DEBUG: Checking out this RM1");
			double total = 0;
			for(int i = 0; i < likelyStructureMemory.length; i++)
				total += likelyStructureMemory[i];
			if((double)likelyStructureMemory[ProbConstants.RM1]/ total <  0.7
					&& (double)likelyStructureMemory[ProbConstants.C1]/ total <= 0.25
					&& (double)likelyStructureMemory[ProbConstants.C2]/ total <= 0.25 ){
				likelyStructure = ProbConstants.RM2;
				System.err.println("DEBUG: Switching from RM1 to RM2!");
			}
		}
	}
	
	private void applyStructureProb(StructureProbabilities sp, double weight, boolean average, int nBeforeAverage){

		if(average){
			structProbs[ProbConstants.RM]  = (structProbs[ProbConstants.RM]*nBeforeAverage+sp.rm)/(nBeforeAverage+1);
			structProbs[ProbConstants.RM1] = (structProbs[ProbConstants.RM1]*nBeforeAverage+sp.rm1)/(nBeforeAverage+1);
			structProbs[ProbConstants.RM2] = (structProbs[ProbConstants.RM2]*nBeforeAverage+sp.rm2)/(nBeforeAverage+1);
			structProbs[ProbConstants.C1]  = (structProbs[ProbConstants.C1]*nBeforeAverage+sp.c1)/(nBeforeAverage+1);
			structProbs[ProbConstants.C2]  = (structProbs[ProbConstants.C2]*nBeforeAverage+sp.c2)/(nBeforeAverage+1);
			structProbs[ProbConstants.PC1] = (structProbs[ProbConstants.PC1]*nBeforeAverage+sp.pc1)/(nBeforeAverage+1);
			structProbs[ProbConstants.S1]  = (structProbs[ProbConstants.S1]*nBeforeAverage+sp.s1)/(nBeforeAverage+1);
			structProbs[ProbConstants.W1]  = (structProbs[ProbConstants.W1]*nBeforeAverage+sp.w1)/(nBeforeAverage+1);
		}
		//TODO: weigh a probability, you idiot?????
		structProbs[ProbConstants.RM] *= sp.rm;
		structProbs[ProbConstants.RM1] *= sp.rm1;
		structProbs[ProbConstants.RM2] *= sp.rm2;
		structProbs[ProbConstants.C1] *= sp.c1;
		structProbs[ProbConstants.C2] *= sp.c2;
		structProbs[ProbConstants.PC1] *= sp.pc1;
		structProbs[ProbConstants.S1] *= sp.s1;
		structProbs[ProbConstants.W1] *= sp.w1;
		
		
	}	
	
	public void setFeatureStructTypeProb(String structType, double structProb){
		if(!this.userSetStructProb){
			feature.setAttribute("struct_typ", structType);
			feature.setAttribute("str_prob", new Double(structProb));
		}
	}
	
	/**
	 * Saves the current structure type and probability 
	 */
	public void saveCurrentStructureMemory(){
		likelyStructureMemory[likelyStructure]++;		
		likelyStructureProbMemory[likelyStructure] += likelyStructureProb;
	}

	
	
	/**
	 * Does as advertised.
	 * @return
	 */
	public int[] getLikelyStructureMemory() {
		return likelyStructureMemory;
	}

	//TODO: ************ FOR NOW WE'RE JUST AVERAGING THE PROBABILITIES
	/**
	 * Does as advertised.
	 * @return
	 */
	public double[] getLikelyStructureProbMemory() {
		double avgPr[] = new double[likelyStructureProbMemory.length];
		for(int i = 0;  i < likelyStructureProbMemory.length; i++)
			avgPr[i] = likelyStructureProbMemory[i]/likelyStructureProbMemory.length;
		return avgPr;
	}

	private void doMajorRoadIndex(){

		if(mriStatsNeeded == null){
			mriStatsNeeded = probParams.getRequiredStatistics(ProbConstants.RP);
			if(mriStatsNeeded == null){
				mriVarsValues = null;
				return;
			}
		}		
		boolean needMean = true;
		boolean needSigma = false;
		boolean needMeanPlusSigma = false;
		boolean needMeanMinusSigma = false;
		boolean needMode = false;
		
		if(mriStatsNeeded.contains(ProbConstants.SIGMA))
			needSigma = true;
		if(mriStatsNeeded.contains(ProbConstants.MEAN_PLUS_SIGMA))
			needMeanPlusSigma = true;
		if(mriStatsNeeded.contains(ProbConstants.MEAN_MINUS_SIGMA))
			needMeanMinusSigma = true;
		if(mriStatsNeeded.contains(ProbConstants.MODE))
			needMode = true;
	
		ArrayList<BuildingClassification> edBuildings = ed.getBuildings();
		double rp[] = new double[edBuildings.size()];
		double maxVal = -1*Double.MAX_VALUE;
		double minVal = Double.MIN_VALUE;
		int n = 0;
		for(Iterator <BuildingClassification> i = edBuildings.iterator(); i.hasNext();){
			rp[n]= i.next().getMajorRoadIndex();
			if(needMode){
				if(maxVal < rp[n])
					maxVal = rp[n];
				if(minVal > rp[n])
					minVal = rp[n];
			}
			n++;
		}		

		//** determine bins and freq and normalize area
		double bins[] = new double[50];
		double rpMean = 0;
		int freq[] = new int[50];
		double inc = (maxVal - minVal)/50;
		if(needMode){
			for(int z = 1; z < bins.length; z++){
				bins[z-1] = (inc*(double)z);//** linspace(min:max, 50)
			}
		}
		int maxFreq = -1;
		int maxFreqIndex = 0;
		for(int i=0; i < rp.length; i++){
			if(needMean){
				rpMean += rp[i];
			}
			
			if(needMode){
				for(int h = 0; h < bins.length;h++){
					if(h == 0){
						if(rp[i] < bins[0]){
							freq[0]++;
							if(freq[h] > maxFreq){
								maxFreq = freq[h];
								maxFreqIndex = h;
							}
							break;
						}
					}
					if(bins[h] <= rp[i]){
						if( h+1 < bins.length && rp[i] < bins[h+1]){
							freq[h]++;
							if(freq[h] > maxFreq){
								maxFreq = freq[h];
								maxFreqIndex = h;
							}
							break;	
						}
						else if( h+1 == bins.length){
							freq[h]++;
							if(freq[h] > maxFreq){
								maxFreq = freq[h];
								maxFreqIndex = h;
							}
						}							
					}					
				}
			}			
		}
		
		if(needMean || needSigma || needMeanPlusSigma|| needMeanMinusSigma){	
			rpMean /= rp.length;
			mriVarsValues.put(ProbConstants.MEAN, new Double(rpMean));
		}
		if(needMode){
			mriVarsValues.put(ProbConstants.MODE, new Double(bins[maxFreqIndex]));
		}			
		
		
				
		double std = 0;
	
		if(needSigma || needMeanPlusSigma|| needMeanMinusSigma){
			for(int i=0; i < rp.length; i++)			
				std += Math.pow(rpMean - rp[i], 2);
			std = Math.sqrt(std/rp.length);
			if(needSigma)
				mriVarsValues.put(ProbConstants.SIGMA, new Double(std));
			if(needMeanPlusSigma)
				mriVarsValues.put(ProbConstants.MEAN_PLUS_SIGMA, new Double(rpMean+std));
			if(needMeanMinusSigma)
				mriVarsValues.put(ProbConstants.MEAN_MINUS_SIGMA, new Double(rpMean-std));
		}
	}
	
	private void doGsqm(){

		if(gsqmStatsNeeded == null){
			gsqmStatsNeeded = probParams.getRequiredStatistics(ProbConstants.BA);
			if(gsqmStatsNeeded == null){
				gsqmVarsValues = null;
				return;
			}
		}		
		boolean needMean = true;
		boolean needSigma = false;
		boolean needMeanPlusSigma = false;
		boolean needMeanMinusSigma = false;
		boolean needMode = false;
		
		if(gsqmStatsNeeded.contains(ProbConstants.SIGMA))
			needSigma = true;
		if(gsqmStatsNeeded.contains(ProbConstants.MEAN_PLUS_SIGMA))
			needMeanPlusSigma = true;
		if(gsqmStatsNeeded.contains(ProbConstants.MEAN_MINUS_SIGMA))
			needMeanMinusSigma = true;
		if(gsqmStatsNeeded.contains(ProbConstants.MODE))
			needMode = true;
	
		ArrayList<BuildingClassification> edBuildings = ed.getBuildings();
		double ba[] = new double[edBuildings.size()];
		int n = 0;
		double maxVal = -1*Double.MAX_VALUE;
		double minVal = Double.MIN_VALUE;
		for(Iterator <BuildingClassification> i = edBuildings.iterator(); i.hasNext();){
			ba[n]= i.next().getGsqm();
			if(needMode){
				if(maxVal < ba[n])
					maxVal = ba[n];
				if(minVal > ba[n])
					minVal = ba[n];
			}
			n++;
		}		

		//** determine bins and freq and normalize area
		double bins[] = new double[50];
		double gsqmEDMean = 0;
		int freq[] = new int[50];
		double inc = (maxVal - minVal)/50;
		if(needMode){
			for(int z = 1; z < bins.length; z++){
				bins[z-1] = (inc*(double)z);//** linspace(min:max, 50)
			}
		}
		int maxFreq = -1;
		int maxFreqIndex = 0;
		for(int i=0; i < ba.length; i++){
			if(needMean){
				gsqmEDMean += ba[i];
			}
			
			if(needMode){
				for(int h = 0; h < bins.length;h++){
					if(h == 0){
						if(ba[i] < bins[0]){
							freq[0]++;
							if(freq[h] > maxFreq){
								maxFreq = freq[h];
								maxFreqIndex = h;
							}
							break;
						}
					}
					if(bins[h] <= ba[i]){
						if( h+1 < bins.length && ba[i] < bins[h+1]){
							freq[h]++;
							if(freq[h] > maxFreq){
								maxFreq = freq[h];
								maxFreqIndex = h;
							}
							break;	
						}
						else if( h+1 == bins.length){
							freq[h]++;
							if(freq[h] > maxFreq){
								maxFreq = freq[h];
								maxFreqIndex = h;
							}
						}							
					}					
				}
			}
		}
		
		if(needMean || needSigma || needMeanPlusSigma|| needMeanMinusSigma){	
			gsqmEDMean /= ba.length;
			gsqmVarsValues.put(ProbConstants.MEAN, new Double(gsqmEDMean));
		}
		if(needMode){
			gsqmVarsValues.put(ProbConstants.MODE, new Double(bins[maxFreqIndex]));
		}						
				
		double std = 0;
	
		if(needSigma || needMeanPlusSigma|| needMeanMinusSigma){
			for(int i=0; i < ba.length; i++)			
				std += Math.pow(gsqmEDMean - ba[i], 2);
			std = Math.sqrt(std/ba.length);
			if(needSigma)
				gsqmVarsValues.put(ProbConstants.SIGMA, new Double(std));
			if(needMeanPlusSigma)
				gsqmVarsValues.put(ProbConstants.MEAN_PLUS_SIGMA, new Double(gsqmEDMean+std));
			if(needMeanMinusSigma)
				gsqmVarsValues.put(ProbConstants.MEAN_MINUS_SIGMA, new Double(gsqmEDMean-std));
		}							
	}
	
	
	private void doIsoperimetricQ(){

		if(isoperimetricQStatsNeeded == null){
			isoperimetricQStatsNeeded = probParams.getRequiredStatistics(ProbConstants.BSR);
			if(isoperimetricQStatsNeeded == null){
				isoperimetricQVarsValues = null;
				return;
			}
		}		
		boolean needMean = true;
		boolean needSigma = false;
		boolean needMeanPlusSigma = false;
		boolean needMeanMinusSigma = false;
		boolean needMode = false;
		
		if(isoperimetricQStatsNeeded.contains(ProbConstants.SIGMA))
			needSigma = true;
		if(isoperimetricQStatsNeeded.contains(ProbConstants.MEAN_PLUS_SIGMA))
			needMeanPlusSigma = true;
		if(isoperimetricQStatsNeeded.contains(ProbConstants.MEAN_MINUS_SIGMA))
			needMeanMinusSigma = true;
		if(isoperimetricQStatsNeeded.contains(ProbConstants.MODE))
			needMode = true;
	
		ArrayList<BuildingClassification> edBuildings = ed.getBuildings();
		double q[] = new double[edBuildings.size()];
		double maxVal = -1*Double.MAX_VALUE;
		double minVal = Double.MIN_VALUE;
		int n = 0;
		for(Iterator <BuildingClassification> i = edBuildings.iterator(); i.hasNext();){
			q[n]= i.next().getIsoperimetricQ();
			if(needMode){
				if(maxVal < q[n])
					maxVal = q[n];
				if(minVal > q[n])
					minVal = q[n];
			}
			n++;
		}		

		//** determine bins and freq and normalize area
		double bins[] = new double[50];
		double qMean = 0;
		int freq[] = new int[50];
		double inc = (maxVal - minVal)/50;
		if(needMode){
			for(int z = 1; z < bins.length; z++){
				bins[z-1] = (inc*(double)z);//** linspace(min:max, 50)
			}
		}
		int maxFreq = -1;
		int maxFreqIndex = 0;
		for(int i=0; i < q.length; i++){
			if(needMean){
				qMean += q[i];
			}
			
			if(needMode){
				for(int h = 0; h < bins.length;h++){
					if(h == 0){
						if(q[i] < bins[0]){
							freq[0]++;
							if(freq[h] > maxFreq){
								maxFreq = freq[h];
								maxFreqIndex = h;
							}
							break;
						}
					}
					if(bins[h] <= q[i]){
						if( h+1 < bins.length && q[i] < bins[h+1]){
							freq[h]++;
							if(freq[h] > maxFreq){
								maxFreq = freq[h];
								maxFreqIndex = h;
							}
							break;	
						}
						else if( h+1 == bins.length){
							freq[h]++;
							if(freq[h] > maxFreq){
								maxFreq = freq[h];
								maxFreqIndex = h;
							}
						}							
					}					
				}
			}			
		}
		
		if(needMean || needSigma || needMeanPlusSigma|| needMeanMinusSigma){	
			qMean /= q.length;
			isoperimetricQVarsValues.put(ProbConstants.MEAN, new Double(qMean));
		}
		if(needMode){
			isoperimetricQVarsValues.put(ProbConstants.MODE, new Double(bins[maxFreqIndex]));
		}			
		
		
				
		double std = 0;
	
		if(needSigma || needMeanPlusSigma|| needMeanMinusSigma){
			for(int i=0; i < q.length; i++)			
				std += Math.pow(qMean - q[i], 2);
			std = Math.sqrt(std/q.length);
			if(needSigma)
				isoperimetricQVarsValues.put(ProbConstants.SIGMA, new Double(std));
			if(needMeanPlusSigma)
				isoperimetricQVarsValues.put(ProbConstants.MEAN_PLUS_SIGMA, new Double(qMean+std));
			if(needMeanMinusSigma)
				isoperimetricQVarsValues.put(ProbConstants.MEAN_MINUS_SIGMA, new Double(qMean-std));
		}
	}
	
	
	private void doIsoperimetricQNeighborhood(){
		//** TODO: if we're not gonna shrink circle with t then do this ONCE with global variables!!!! 

		//ArrayList<String> isoPQNStatsNeeded;
		if(isoPQNStatsNeeded == null){
			isoPQNStatsNeeded = probParams.getRequiredStatistics(ProbConstants.BSRN);
			if(isoPQNStatsNeeded == null){
				isoPQNVarsValues = null;
				return;
			}
		}		
		boolean needMean = true;
		boolean needSigma = false;
		boolean needMeanPlusSigma = false;
		boolean needMeanMinusSigma = false;
		boolean needMode = false;
		
		if(isoPQNStatsNeeded.contains(ProbConstants.SIGMA))
			needSigma = true;
		if(isoPQNStatsNeeded.contains(ProbConstants.MEAN_PLUS_SIGMA))
			needMeanPlusSigma = true;
		if(isoPQNStatsNeeded.contains(ProbConstants.MEAN_MINUS_SIGMA))
			needMeanMinusSigma = true;
		if(isoPQNStatsNeeded.contains(ProbConstants.MODE))
			needMode = true;		
	
		double q[] = new double[neighbors.size()];
		double maxVal = -1*Double.MAX_VALUE;
		double minVal = Double.MIN_VALUE;
		int n = 0;
		for(Iterator <BuildingClassification> i = neighbors.iterator(); i.hasNext();){
			BuildingClassification t = i.next();
			q[n]= t.getIsoperimetricQ();
			if(needMode){
				if(maxVal < q[n])
					maxVal = q[n];
				if(minVal > q[n])
					minVal = q[n];
			}
			n++;
		}
		

		//** determine bins and freq and normalize area
		double bins[] = new double[50];
		double qNMean = 0;
		int freq[] = new int[50];
		double inc = (maxVal - minVal)/50;
		if(needMode){
			for(int z = 1; z < bins.length; z++){
				bins[z-1] = (inc*(double)z);//** linspace(min:max, 50)
			}
		}
		int maxFreq = -1;
		int maxFreqIndex = 0;
		for(int i=0; i < q.length; i++){
			if(needMean){
				qNMean += q[i];
			}
			
			if(needMode){
				for(int h = 0; h < bins.length;h++){
					if(h == 0){
						if(q[i] < bins[0]){
							freq[0]++;
							if(freq[h] > maxFreq){
								maxFreq = freq[h];
								maxFreqIndex = h;
							}
							break;
						}
					}
					if(bins[h] <= q[i]){
						if( h+1 < bins.length && q[i] < bins[h+1]){
							freq[h]++;
							if(freq[h] > maxFreq){
								maxFreq = freq[h];
								maxFreqIndex = h;
							}
							break;	
						}
						else if( h+1 == bins.length){
							freq[h]++;
							if(freq[h] > maxFreq){
								maxFreq = freq[h];
								maxFreqIndex = h;
							}
						}							
					}					
				}
			}			
		}
		
		if(needMean || needSigma || needMeanPlusSigma|| needMeanMinusSigma){	
			qNMean /= q.length;
			isoPQNVarsValues.put(ProbConstants.MEAN, new Double(qNMean));
		}
		if(needMode){
			isoPQNVarsValues.put(ProbConstants.MODE, new Double(bins[maxFreqIndex]));
		}			
		
		
				
		double std = 0;
		isoperimetricQNeighborhood = 0;
		//** see documentation for explanation of the following which measures simlarity of the neighbors
		for(int i=0; i < q.length; i++){
			if(needSigma || needMeanPlusSigma|| needMeanMinusSigma){
				std += Math.pow(qNMean - q[i], 2);
			}
			isoperimetricQNeighborhood += Math.abs(q[i]-qNMean);			
		}
		if(needSigma || needMeanPlusSigma|| needMeanMinusSigma){
			std = Math.sqrt(std/q.length);
			if(needSigma)
				isoPQNVarsValues.put(ProbConstants.SIGMA, new Double(std*0.75));//** why 0.75 ?? PROVE IT TODO
			if(needMeanPlusSigma)
				isoPQNVarsValues.put(ProbConstants.MEAN_PLUS_SIGMA, new Double(qNMean+std));
			if(needMeanMinusSigma)
				isoPQNVarsValues.put(ProbConstants.MEAN_MINUS_SIGMA, new Double(qNMean-std));
		}
		isoperimetricQNeighborhood = isoperimetricQNeighborhood/(q.length-1);
							
		
	}
	
	private void doGsqmNeighborhood(){
		//** TODO: if we're not gonna shrink circle with t then do this ONCE with global variables!!!!

		if(gsqmNStatsNeeded == null){
			gsqmNStatsNeeded = probParams.getRequiredStatistics(ProbConstants.BAN);
			if(gsqmNStatsNeeded == null){
				gsqmNeighVarsValues = null;
				return;
			}
		}		
		boolean needMean = true;
		boolean needSigma = false;
		boolean needMeanPlusSigma = false;
		boolean needMeanMinusSigma = false;
		boolean needMode = false;

		if(gsqmNStatsNeeded.contains(ProbConstants.SIGMA)){
			needSigma = true;
		}
		if(gsqmNStatsNeeded.contains(ProbConstants.MEAN_PLUS_SIGMA))
			needMeanPlusSigma = true;
		if(gsqmNStatsNeeded.contains(ProbConstants.MEAN_MINUS_SIGMA))
			needMeanMinusSigma = true;
		if(gsqmNStatsNeeded.contains(ProbConstants.MODE))
			needMode = true;
		
	
		double gsqmN[] = new double[neighbors.size()];
		int n = 0;
		double maxVal = -1*Double.MAX_VALUE;
		double minVal = Double.MIN_VALUE;
		for(Iterator <BuildingClassification> i = neighbors.iterator(); i.hasNext();){
			BuildingClassification t = i.next();
			gsqmN[n]= t.getGsqm();
			if(needMode){
				if(maxVal < gsqmN[n])
					maxVal = gsqmN[n];
				if(minVal > gsqmN[n])
					minVal = gsqmN[n];
			}
			n++;
		}
		

		//** determine bins and freq and normalize area
		double bins[] = new double[50];
		double gsqmNMean = 0;
		int freq[] = new int[50];
		double inc = (maxVal - minVal)/50;
		if(needMode){
			for(int z = 1; z <= bins.length; z++){
				bins[z-1] = (inc*(double)z);//** linspace(min:max, 50)
			}
		}
		int maxFreq = -1;
		int maxFreqIndex = 0;
		for(int i=0; i < gsqmN.length; i++){
			if(needMean){
				gsqmNMean += gsqmN[i];
			}
			if(needMode){
				for(int h = 0; h < bins.length;h++){
					if(h == 0){
						if(gsqmN[i] < bins[0]){
							freq[0]++;
							if(freq[h] > maxFreq){
								maxFreq = freq[h];
								maxFreqIndex = h;
							}
							break;
						}
					}
					if(bins[h] <= gsqmN[i]){
						if( h+1 < bins.length && gsqmN[i] < bins[h+1]){
							freq[h]++;
							if(freq[h] > maxFreq){
								maxFreq = freq[h];
								maxFreqIndex = h;
							}
							break;	
						}
						else if( h+1 == bins.length){
							freq[h]++;
							if(freq[h] > maxFreq){
								maxFreq = freq[h];
								maxFreqIndex = h;
							}
						}							
					}					
				}
			}			
		}
			
		if(needMean || needSigma || needMeanPlusSigma|| needMeanMinusSigma){	
			gsqmNMean /= gsqmN.length;
			gsqmNeighVarsValues.put(ProbConstants.MEAN, new Double(gsqmNMean));
		}
		if(needMode){	
			gsqmNeighVarsValues.put(ProbConstants.MODE, new Double(bins[maxFreqIndex]));
		}			
				
				
		double std = 0;
		gsqmNeighborhood = 0;
		//** see documentation for explanation of the following which measures simlarity of the neighbors
		for(int i=0; i < gsqmN.length; i++){
			if(needSigma || needMeanPlusSigma|| needMeanMinusSigma){
				std += Math.pow(gsqmNMean - gsqmN[i], 2);
			}
			
			gsqmNeighborhood += Math.abs(gsqmN[i]-gsqmNMean);	
		}
		if(needSigma || needMeanPlusSigma|| needMeanMinusSigma){
			std = Math.sqrt(std/gsqmN.length);
			if(needSigma)
				gsqmNeighVarsValues.put(ProbConstants.SIGMA, new Double(std));
			if(needMeanPlusSigma)
				gsqmNeighVarsValues.put(ProbConstants.MEAN_PLUS_SIGMA, new Double(gsqmNMean+std));
			if(needMeanMinusSigma)
				gsqmNeighVarsValues.put(ProbConstants.MEAN_MINUS_SIGMA, new Double(gsqmNMean-std));
		}
		gsqmNeighborhood = gsqmNeighborhood/(gsqmN.length-1);
		
	}
	
	private void doIncomeZone(){
		if(inzStatsNeeded == null){
			inzStatsNeeded = probParams.getRequiredStatistics(ProbConstants.INZ);
			if(inzStatsNeeded == null){
				inzStatsNeeded = null;
				return;
			}
		}	
		
		//**TODO: WE ONLY NEED UPPER PERCENTILES HERE FOR INCOME ZONES. I AM CERTAIN OF THIS!
		if(inzStatsNeeded.contains(ProbConstants.UPPER_NINETY_PERCENTILE)){
			inzVarsValues.put(ProbConstants.UPPER_NINETY_PERCENTILE, new Double(ed.getUpper90PercentileUnimpLandVal()));
		}							
		if(inzStatsNeeded.contains(ProbConstants.UPPER_EIGHTY_PERCENTILE)){
			inzVarsValues.put(ProbConstants.UPPER_EIGHTY_PERCENTILE, new Double(ed.getUpper80PercentileUnimpLandVal()));
		}			
		if(inzStatsNeeded.contains(ProbConstants.UPPER_SEVENTY_PERCENTILE)){
			inzVarsValues.put(ProbConstants.UPPER_SEVENTY_PERCENTILE, new Double(ed.getUpper70PercentileUnimpLandVal()));
		}
		meanUnImpLandValue = ed.getMeanUnimpLandVal();
	}
	
	private void doNeighbouringStructTypes(){
		//
		int structCount[]  = new int[neighborStructs.length];
		for(int i = 0; i < structCount.length; i++)
			structCount[i] = 0;
		for(Iterator <BuildingClassification> i = neighbors.iterator(); i.hasNext();){
			BuildingClassification n = i.next(); 
			if(n.getMostLikelyStructure() > 0)
				structCount[n.getMostLikelyStructure()]++;
		}
		
		/** We want these ratios to boost already high probabilities, not squash them.
		 *  Values will be between 0.8 and 1 and will be scaled by a sigmoid function. 
		 */
		for(int i = 0; i < structCount.length; i++){
			// k = 40, x0 = 0.85, C = 0.8
			neighborStructs[i] = LogisticFunction.logisticFunction( 
			(double)structCount[i]/(double)neighbors.size(),
			40, 0.85, 0.8, false);
		}
		neighborStructProb.c1 = neighborStructs[ProbConstants.C1];
		neighborStructProb.c2 = neighborStructs[ProbConstants.C2];
		neighborStructProb.rm = neighborStructs[ProbConstants.RM];
		neighborStructProb.rm1 = neighborStructs[ProbConstants.RM1];
		neighborStructProb.rm2 = neighborStructs[ProbConstants.RM2];
		neighborStructProb.pc1 = neighborStructs[ProbConstants.PC1];
		neighborStructProb.w1 = neighborStructs[ProbConstants.W1];
		neighborStructProb.s1 = neighborStructs[ProbConstants.S1];

	}
	
	private void createNeighborhoodCircle(){
		//** lets define neighborhoodRadius as a quarter the longest edge of the bounding box of the ed this building is in
		double edy = ed.getFeature().getBounds().getHeight();
		double edx = ed.getFeature().getBounds().getWidth();
		double neighborhoodRadius = -1;
		if( edx > edy)
			neighborhoodRadius = edy/4;	
		else
			neighborhoodRadius = edx/4;

		
		//** build circle geometry
		Point p  = ((Geometry)this.getFeature().getDefaultGeometry()).getCentroid();		
		
        Coordinate coords[] = new Coordinate[50]; //** hard code to use only 50 points   
        double inc = 2*Math.PI/50;
        int n = -1;
        for(double a = -Math.PI;a < Math.PI; a+=inc){        
            n++;
            coords[n] = new Coordinate(p.getX()+(neighborhoodRadius*Math.sin(a)),
            		p.getY()+(neighborhoodRadius*Math.cos(a)));
        }       
        coords[n] = coords[0];//close circle   

        GeometryFactory fact = new GeometryFactory();
        try{
            LinearRing linear = new GeometryFactory().createLinearRing(coords);
            circle = new Polygon(linear, null, fact);
        }catch(IllegalArgumentException iaex){        	
        	iaex.printStackTrace();
        }
	}
	
		
		
	//** GETTERS AND SETTERS BEYOND HERE **	
	public GeoHash getAllBuildings() {
		return allBuildings;
	}

	public void setAllBuildings(GeoHash allBuildings) {
		this.allBuildings = allBuildings;
	}
	
	public EDStructTypeRankingFunction getED() {
		return ed;
	}


	public void setED(EDStructTypeRankingFunction ed) {
		this.ed = ed;		
	}
	

	public BuildingProbParameters getProbParams() {
		return probParams;
	}	
		
    public int getNoOfVertices() {
		return noOfVertices;
	}

	public void setNoOfVertices(int noOfVertices) {
		this.noOfVertices = noOfVertices;
	}

	public double getIsoperimetricQ() {
		return isoperimetricQ;
	}

	public void setIsoperimetricQ(double isoperimetricQ) {	
		this.isoperimetricQ = isoperimetricQ;
	}

	public double getMajorRoadIndex() {
		return majorRoadIndex;
	}

	public void setMajorRoadIndex(double majorRoadIndex) {
		this.majorRoadIndex = majorRoadIndex;
	}

	public double getGsqm() {
		return gsqm;
	}


	public void setGsqm(double gsqm) {
		this.gsqm = gsqm;
	}	
	
	public double getMeanUnImpLandValue() {
		return meanUnImpLandValue;
	}

	public void setMeanUnImpLandValue(double meanUnImpLandValue) {
		this.meanUnImpLandValue = meanUnImpLandValue;
	}

	public SimpleFeature getFeature() {
		return feature;
	}

	public void setFeature(SimpleFeature feature) {
		this.feature = feature;
	}

	public double getStructuresProbability(int struct){
		return structProbs[struct];
	}
	
	public void setStructuresProbability(int struct, double probability){
		likelyStructureProb = probability;
		structProbs[struct] = probability;
	}
	
	public double[] getAllStructuresProbabilities(){
		return structProbs;
	}
	

	/**
	 * Returns constants from ProbConstants
	 * @return
	 */
	public int getMostLikelyStructure(){		
		return likelyStructure;
	}
	
	/**
	 * 
	 * Accepts constants from ProbConstants
	 * @param likelyStructure
	 */
	public void setMostLikelyStructure(int likelyStructure){
		this.likelyStructure = likelyStructure;
	}
	
	public String getMostLikelyStructureString(){
		return likelyStructureStr;
	}
	
	
	public String getBldgID() {
		return bldgID;
	}

	public void setBldgID(String bldgID) {
		this.bldgID = bldgID;
	}

	//** GeoHashable methods
	/* (non-Javadoc)
     * @see com.uwiseismic.util.geohash.GeoHashable#getCentroid()
     */
    public Point getCentroid() {
        return ((Geometry)feature.getDefaultGeometry()).getCentroid();
    }

    /* (non-Javadoc)
     * @see com.uwiseismic.util.geohash.GeoHashable#getEnvelope()
     */
    public Geometry getEnvelope() {
        return ((Geometry)feature.getDefaultGeometry()).getEnvelope();
    }

    /* (non-Javadoc)
     * @see com.uwiseismic.util.geohash.GeoHashable#getGeometry()
     */
    public Geometry getGeometry() {
        return (Geometry)feature.getDefaultGeometry();
    }
	
	
	
}
